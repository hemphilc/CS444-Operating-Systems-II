\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\usepackage{multirow}

\usepackage{geometry}
\geometry{textheight=9.5in, textwidth=7in}

% 1. Fill in these details
\def \OperatingSystemTwo{Group 46}
\def \OSTwoGroupNumber{46}
\def \GroupMemberOne{Corey Hemphill}
\def \GroupMemberTwo{Jason Ye}
\def \HomeworkAssignmentOne{Getting Acquainted}
\def \HomeworkDueDate{October 9, 2017}


% 2. Uncomment the appropriate line below so that the document type works
\def \DocType{	%Problem Statement
				%Requirements Document
				%Technology Review
				%Design Document
				Project 1 Report
				}
			
\newcommand{\NameSigPair}[1]{\par
\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill	\makebox[.75in]{\hrulefill}}
\par\vspace{-12pt} \textit{\tiny\noindent
\makebox[2.75in]{} \hfil		\makebox[3.25in]{\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}}}}
% 3. If the document is not to be signed, uncomment the RENEWcommand below
%\renewcommand{\NameSigPair}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{titlepage}
    \pagenumbering{gobble}
    \begin{singlespace}
    	\includegraphics[height=4cm]{coe_v_spot1}
        \hfill 
        % 4. If you have a logo, use this include graphics command to put it on the coversheet.
        %\includegraphics[height=4cm]{CompanyLogo}   
        \par\vspace{.2in}
        \centering
        \scshape{
            \huge  \DocType \par
           	\huge cs444 Fall17 \par
            {\large\today}\par
            \vspace{.5in}
            \textbf{\Huge\HomeworkAssignmentOne}\par
            \vspace{.5in}
           
            {\large Prepared by }\par
           	\textbf{\GroupMemberOne}\par
            \textbf{\GroupMemberTwo}\par
            % 5. comment out the line below this one if you do not wish to name your team
   
            \vspace{5pt}
            
            \textbf{\Huge\ \OperatingSystemTwo}\par
            }
            \vspace{60pt}
        
        \begin{abstract}
        % 6. Fill in your abstract     
        \end{abstract} 
        
    \end{singlespace}
\end{titlepage}
\newpage
\pagenumbering{arabic}
\tableofcontents
% 7. uncomment this (if applicable). Consider adding a page break.
%\listoffigures
%\listoftables
\clearpage

% 8. now you write!

\section{List of Commands}
% list the command lines from beginning to execute in the terminal

\begin{enumerate}
\item cd \textless directory\textgreater
\item vim \textless filename\textgreater
\item git clone git://git.yoctoproject.org/linux-yocto-3.19
\item git tag -l
\item git checkout tags/v3.19.2
\item git checkout tags/v3.19.2 -b branch linux-yocto-3.19.2
\item git pull https://github.com/hemphilc/CS444-Operating-Systems-II/
\item git push https://github.com/hemphilc/CS444-Operating-Systems-II/
\item make menuconfig
\item make
\item ctags -R
\item setenv \textless name\textgreater \textless value\textgreater
\item qemu-system-i386 -gdb tcp::5546 -S -nographic -kernel bzImage-linux-yocto-3.19.2 -drive file=core-image-lsb-sdk-qemux86.ext4,if=virtio -enable-kvm -net none -usb -localtime --no-reboot --append "root=/dev/vda rw console=ttyS0 debug"
\item cp \textless filename\textgreater \textless directory\textgreater
\item gcc -pthread -Wall -g concurrency.c -o concurrency
\item history
\end{enumerate}

\section{Qemu Flags}
The command flags used to initiate the qemu virtual machine are necessary in order to achieve a reasonable amount of performance. Without these flags, our kernel would run extremely slow. The full command used to initialize the qemu vm is as follows:\newline
\newline
\noindent qemu-system-i386 -gdb tcp::5546 -S -nographic -kernel bzImage-linux-yocto-3.19.2 -drive file=core-image-lsb-sdk-\newline qemux86.ext4,if=virtio -enable-kvm -net none -usb -localtime --no-reboot --append "root=/dev/vda rw console=ttyS0 debug"\newline
\newline
Below is a list of each command flag used in the initialization command and its respective purpose:

\begin{itemize}

\item gdb:  enables kernel debugging via a remote instance of gdb
\item tcp:  indicates a port number for gdb to connect to for debugging purposes
\item S:  freezes the CPU on VM start
\item nographic:  disables all graphical output and redirects serial I/Os to the console
\item kernel:  indicates a bzImage to use for boot
\item drive file:  indicates a file system to use for boot
\item enable-kvm: enables full virtualization support
\item net none:  dumps network traffic on virtual lan (vlan) from 'n' file to 'f' file - zero network devices
\item usb:  enables the USB driver
\item localtime:  sets the real time clock base and clock to local cpu time
\item no-reboot:  shutdown instead of reboot
\item append:  appends a command string to use in kernel command line 

\end{itemize}

\noindent 
% Write how to build kernel and run qemu on OS-Class... 
\\


\section{Concurrency Solution}

\subsection{Solution Summary}

\noindent
We implemented a single C file, concurrency.c that consists of 3 key functions; a random number generator, a producer, and a consumer. The main function simply initializes the mutex, and creates the producer and consumer threads. The rdrand function generates a random value within a given range, and is used for generating the random wait times for the producer and consumer functions. The producer waits a random amount of time between 3 and 7 seconds, generates a data struct with a random value and a random wait time between 2 and 9, adds it to a global data buffer, and increments the buffer item count. While the producer performs its insert, it uses a mutex to take sole control of the data buffer. The consumer grabs the last value inserted into the data buffer, consumes it, decrements the buffer item count, and prints the data's value to the console. While the consumer performs its removal, it uses a mutex to take sole control of the data buffer. We hard-coded the program to use 2 producer and 2 consumer threads - 4 total so as not to go over the enforced server thread limit. 
\\

\subsection{What do you think the main point of this assignment is}

\noindent 
The main focus of this assignment was to review concepts from CS344 such as multi-threading, and implement a solution to the producer-consumer concurrency problem in C. The assignment is meant to get students thinking about the concept of concurrency, as well as reintroduce multi-threading using the pthread library, and interacting with a shared resource using producer and consumer functions. In addition to concurrency concepts, the assignment was a programming exercise in performing insert and remove operations on a data structure, and mutex functionality. Overall, the assignment was a practice in parallel thinking. 
\\

\subsection{How did you personally approach the problem? Design decisions, algorithm, etc.}

\noindent 
First, we started out examining the course material files provided on the course website by the instructor. The pthread\_hello.c and mt19937ar.c files were enough to provide a solid foundation and get us started on the concurrency problem. Jason tackled the problem by implementing the producer and consumer functions, initializing and utilizing mutexes, creating pthreads, and initializing data structures and variables. Jason also implemented the mutex lock/unlock control logic within the producer and consumer functions. Afterward, Corey implemented the necessary global variables, the main function, debugging and verbose print modes for testing, and general code formatting and style management.
\\


\subsection{How did you ensure your solution was correct? Testing details, for instance.}
\noindent 
We implemented verbose comments within our program so we could easily track each operation that occurs while the program executes its multiple threads. The verbose printing allowed us to verify that the program was behaving as we expected it to. The output can also be easily written to a file rather than directly to the console. When working with multiple threads, its virtually impossible to predict which threads will finish when, so to better understand what was going on when our program executed, it made the most sense to implement verbose comments.
\\


\subsection{What did you learn?}
\noindent 
From this assignment we learned a lot about kernel and Qemu in the Yocto environment. Learning about to set up the environment was definitely a challenge at first, but we feel like once we get comfortable with it we can use it better in the future. Also, we learned how to use multi-threads, thread interaction, and pthread in C.   
\\ 
\section{Version Control Log}
\begin{tabular}{l l l}
\textbf{Detail} & \textbf{Author} & \textbf{Description}\\
\hline asdfas & asdfas & asdfas  \\
\hline asdfas & asdfas & asdfas  \\
\hline asdfas & asdfas & asdfas  \\

\end{tabular}


\section{Work Log}
% List out the work by each member. Briefly state the date and description of the work. 
\begin{itemize}
\item \textit{10/02/2017}\\ Jason and Corey learning how to build Kernel and run Qemu \\
\item \textit{10/03/2017}\\ Jason started concurrency setup in Github and Concurrency research\\
\item \textit{10/03/2017}\\ Jason started concurrency.c. Added provided files and created functions, variables, and structs.  \\
\item \textit{10/04/2017}\\ Corey figured out how to build kernel and ran Qemu successfully. He demonstrated to Jason and completed the first part of the project.\\ 
\item \textit{10/05/2017}\\ Jason completed a prototype of the concurrency.c with a complete producer and consumer functions along with random number generator. Missing the main function and function prototype. \\
\item \textit{10/06/2017}\\



\end{itemize}






\end{document}
